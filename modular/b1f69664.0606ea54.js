(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return c}));var a=n(3),o=n(8),i=(n(0),n(99)),s={id:"views",title:"Views Explained",sidebar_label:"Views Explained"},r={unversionedId:"overview/views",id:"overview/views",isDocsHomePage:!1,title:"Views Explained",description:"User Interfaces are made of components. When you sketch a wireframe on a",source:"@site/docs/overview/views.md",slug:"/overview/views",permalink:"/modular/docs/overview/views",version:"current",sidebar_label:"Views Explained",sidebar:"docs",previous:{title:"Getting Started With Modular",permalink:"/modular/docs/overview/getting-started"}},l=[],p={rightToc:l};function c(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"User Interfaces are made of components. When you sketch a wireframe on a\nwhiteboard or graphics tool of choice, the rectangles that you draw define the\nvisual and semantic boundaries of these components. They usually correspond to\nsome equivalent in your UI framework (e.g - In\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/components-and-props.html"}),"React"),", these are defined\nas classes that extend from React.Component, or regular functions that return\nJSX. In ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://flutter.dev/docs/development/ui/widgets"}),"Flutter"),", these are\nclasses that extend from different types of Views. In\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://developer.android.com/jetpack#foundation-components"}),"Jetpack Compose"),",\nthese are called Composable Functions). These are a neat unit of encapsulating\nstate, behaviour and presentation. They also ",Object(i.b)("em",{parentName:"p"},"compose")," with each other to\nprovide higher abstraction of UI, eventually forming the application itself."),Object(i.b)("p",null,"Every application also has a concept of 'primary' components. These are\n'top-level' components that are considered special, and most important when\ndescribing the high level architecture of an application."),Object(i.b)("p",null,"For example, a site that operates as a blog will probably have these primary\ncomponents - ",Object(i.b)("inlineCode",{parentName:"p"},"<Home/>"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<Posts query={query}>"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<Post id={id}/>"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"<Contact/>"),". These would associate with routes like ",Object(i.b)("inlineCode",{parentName:"p"},"/"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"/posts?offset=20&length=10"),", ",Object(i.b)("inlineCode",{parentName:"p"},"/post/:id/:slug"),", ",Object(i.b)("inlineCode",{parentName:"p"},"/contact"),". Further, ",Object(i.b)("inlineCode",{parentName:"p"},"<Home/>"),"\nmay just be an alias for ",Object(i.b)("inlineCode",{parentName:"p"},"<Posts/>")," with a default query. It all depends on\nwhoever's implementing the site, of course. Each of these components would be\ncomposed of a number of secondary components (and could also be sharing these\ncomponents among themselves)."),Object(i.b)("p",null,"An e-commerce site would have different primary component, ",Object(i.b)("inlineCode",{parentName:"p"},"<Home/>"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"<Search query={query}/>"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<Details id={id}/>"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<Checkout/>"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<Payment/>"),",\nand ",Object(i.b)("inlineCode",{parentName:"p"},"<Profile id={id}/>"),". Like the above, it could also have routing patterns\nfor each of these components, and could be composed by a number of secondary\ncomponents."),Object(i.b)("p",null,"For applications that behave like dashboards, we still have the concept of\nprimary components; there will be a host/container component (let's say we call\nit ",Object(i.b)("inlineCode",{parentName:"p"},"<App/>"),"), but pages will be composed of a number of primary components\n(which could be charts, graphs, tables, lists; whatever developers and product\nmanagers feel is a window into a data slice relevant to a user). Routes are then\nused to show different user-generated dashboards composed of these primary\ncomponents (the layouts for which are probably stored on a database somewhere),\nor for drilling down into a particular component to expose and interact with\nmore data. As before, these primary components are composed of a number of\nsecondary components, possibly sharing low level components amongst themselves."),Object(i.b)("p",null,"In ",Object(i.b)("inlineCode",{parentName:"p"},"modular"),", these primary components are what we call 'views'."),Object(i.b)("p",null,"As these sites scale through time, we notice some patterns emerge in the\ndevelopment of views. They'll usually start as single files, usually all under\none main folder. As each page gains more functionality, they'll become folders,\nwith supporting components/models/functions split into files in that folder.\nThey'll also start getting more developers attached to each primary component;\nfull teams and roadmaps that become part of a broader plan for the\nsite/application. Each of these views will start managing their own specific\ndependencies, and they'll decoupled from the main application in one of a number\nof ways (i.e. microfrontends, or as separate workspaces, or separate packages,\nor repositories that publish assets to a cdn, and so on.) Managing the growth of\nthese components and associated development practices and architecture then\nbecomes key to being able to iterate features safely, quickly, and reliably."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"modular")," suggests 3 strategies for managing the growth of these components."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Strategy 0"),": Try to keep the codebase as small as possible, for as long as\npossible."),Object(i.b)("p",null,"The best kind of scale is no scale at all. As such, it would introduce\nunnecessary complexity to a codebase if it takes on scaling strategies when only\n1 (or few) developers are working on it, only for a little time, and for very\nlow stakes. In such a situation it would be a mistake to build a completely\ndecomposed architecture of React components with a design system, split into\nmultiple parts and files, when instead it could have been built with a plain\nhtml file and an accompanying css file. If this is your situation, you do not\nneed ",Object(i.b)("inlineCode",{parentName:"p"},"modular"),", and you should invest your time and effort into something that\nhas better returns. If you do need a javascript framework, try to keep it in one\nfile. Split into multiple files only when it's painful. Only when you've\nexhausted these basic scaling options, should you move on to the next option..."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Strategy 1"),": Move development of the view to a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://classic.yarnpkg.com/en/docs/workspaces/"}),"workspace"),"."),Object(i.b)("p",null,"If keeping each primary component in a sub-folder is causing growing pains in\nthe codebase, move it to a workspace. Workspaces are a great option, because\nthey provide some benefits of decoupling from the main application, without\nlosing the benefits of colocating within the same repository. Of note:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Teams will be able to declare and manage their own dependencies instead of it\nall being crammed into a central package.json")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"These components could (theoretically) be used in other applications, since\nthey could be published from this workspace as a package (we try to avoid\nthis. I should probably remove this point altogether.)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A sense of ownership for the team; they can define their own\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners"}),"CODEOWNERS"),"\nand code review flow, and most of their PRs and changes won't affect the\nworking of the rest of the application.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"However, since they're all under one typescript project, they still won't\nbreak expectations (or if they do, the static type system will catch it and\nmake you fix it to proceed with a commit/deploy)")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Similarly, tests will run for the entire repository, and assuming there's some\nform of integration/e2e coverage, it'll be hard to break expectations despite\nworking in this isolated manner.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"It is relatively easy to make upgrades in this system; a core dependency can\nbe updated, types and tests checked across the system, and changes committed\nin an atomic fashion. Something that would take weeks (if not months) in a\ndistributed repo system will take a day or so (if not hours) in this\ncentralised system."))),Object(i.b)("p",null,"In a repository generated by ",Object(i.b)("inlineCode",{parentName:"p"},"modular"),", you can add a view by running\n",Object(i.b)("inlineCode",{parentName:"p"},"modular add <name>"),", and choosing the option to create a View. This creates a\nnew workspace with the view name, that can be imported from the application, or\nany of the other workspaces, but still will be included in the main build, and\nparticipates in the type/test infrastructure. Since they're still regular React\ncomponents, you can wrap them with\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/code-splitting.html#reactlazy"}),"React.lazy")," and use\nthem as regular components, but they won't be included in the main bundle, and\nwill load dynamically on demand. This is dope."),Object(i.b)("p",null,"Now, with the dashboard usecase, there's usually never explicit code that\nrenders a specific view; 'layouts' are loaded from a database/service. To make\nthis system work well with ",Object(i.b)("inlineCode",{parentName:"p"},"modular"),", ",Object(i.b)("inlineCode",{parentName:"p"},"modular")," has a special module\n",Object(i.b)("inlineCode",{parentName:"p"},"modular-views.macro"),"; this module\nexports an object that maps every view (wrapped with ",Object(i.b)("inlineCode",{parentName:"p"},"React.lazy"),") to a string\nidentifier (i.e. - the name of the view)"),Object(i.b)("p",null,"(question: do we want to use some other identifier? this seems sufficient for\nnow, but something to keep an eye on.)"),Object(i.b)("p",null,"This gives a scalable local registry of all the views/primary component, and\nit's never necessary to manually update this map since it's defined based on the\nstate of the filesystem. This then becomes our primary system of 'dynamically'\nloading and rendering views onto a rendering surface; we leverage and build on\nregular javascript/React semantics instead of inventing something bespoke. This\nis the power of colocating code in the same repository and scaling\ninfrastructure and tooling around it."),Object(i.b)("p",null,"NB: It could be that someone has done a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://gist.github.com/threepointone/d62b4d92a1e92df5f2f4d2d91a0582cd"}),"sparse checkout"),"\nof the repository and not included all the views in their local instance; no\nproblem, the map excludes those views from the map, and when rendered you can\nuse a generic placeholder component."),Object(i.b)("p",null,"There are some cons to this system, and it's important to note that we're\ntrading one set of problems for these. However, these problems are a better set\nof problems to have, have a lot of historical research and precedence and thus\naren't unique problems, and can be solved incrementally."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Builds might become fairly big: In most cases, as long as you're not building\na systems with many (read: 100s or 1000s of views), the build for such a\nsystem shouldn't be a problem. However, if you are building at that big a\nscale, you can expect the requirements for build infrastructure to increase\nproportionally. In that scenario, there are 3 'solutions':"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Invest in having beefier hardware for doing builds (instead of a farm of\nweaker machines). This will give you some breathing space and time to fix\nroot problems.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Invest in better tooling infrastructure; publicly available tools like\nwebpack/parcel weren't built to handle that kind of scale. Consider adopting\nguidelines from\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/guides/build-performance/"}),"webpack's performance recommendations"),".\nWe are also aware that these tools are considering scale as a first class\nfeature for newer versions, introducing features like module federation,\npersistent caching, incremental builds, and so on.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"At this scale, it's not sufficient to simply follow public guidance, it'll\nprobably be necessary to hire and invest in teams whose sole purpose is to\nsolve these problems, much like big corps like facebook, google, etc do.\n",Object(i.b)("inlineCode",{parentName:"p"},"modular"),"is also working on providing these optimisations by default.")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Developer Workflow: Your teams may not be used to working in a single\nrepository, and as such, may not have the tooling or guidance to do so. Some\nthings that may make this better:"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"setting up\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners"}),"CODEOWNERS"),"\nso every developer is not spammed with notifications about every PR, and\nonly relevant people are targeted as reviewers.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Using a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://gist.github.com/threepointone/2c2fae0622681284410ec9edcc6acf9e"}),"feature flag service"),"\nto simplify uat/deploy workflows")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"using\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://gist.github.com/threepointone/d62b4d92a1e92df5f2f4d2d91a0582cd"}),"sparse checkouts"),"\nto only work on the part of the codebase that's relevant to a developer")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"using a configuration service / key management service for holding and\nmanaging private/public keys used by the system")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Fighting ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Conway%27s_law"}),"Conway's law")," (There's\na whole spiel here about fighting company org structures that we'll write\nabout some day)"))),Object(i.b)("p",null,"We DO NOT recommend pulling your view into a another repository. There are\nserious costs associated with this (TODO, critical: enumerate all the problems\nwith pulling into a separate repo / the multi repository architecture). However,\nyou may be dealing with a legacy/preexisting system where views/primary\ncomponents are defined and built in separate repositories, or some bespoke\ncomponent registry/loading system. We present a couple of strategies to\ninterface with those views:"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Strategy 2"),": Wrap with a React component that establishes an interface\nbetween your application and the component's expectations."),Object(i.b)("p",null,"The idea here is to write a component that takes props that define how to load\nand interface with a fully decoupled component. For example, you may have a\nregistry of components that are defined by a urls that are to be used as an\niframe src, and have a postmessage based api to communicate across the iframe\nboundary. The wrapper component would then look something like this -"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function IframeWrap({ src }) {\n  const iframeChannel = useContext(IframeWrapContext);\n\n  const ref = useRef(null);\n\n  useEffect(() => {\n    // setup communication to send/receive data on iframeChannel\n\n    return () => {\n      // cleanup listeners\n    };\n  });\n\n  return <iframe src={src} ref={ref} />;\n\n  // enhancement - wrap this with React.lazy which resolves on iframe onload (or some other signal)\n}\n")),Object(i.b)("p",null,"And somewhere at the top of your hierachy, expose the ",Object(i.b)("inlineCode",{parentName:"p"},"iframeChannel")," context on\na provider. It might look something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"const IframeWrapContext = React.createContext(null);\n\nfunction App() {\n  return (\n    <IframeWrapContext.Provider value={iframeChannel}>\n      {/* ... load layouts ... */}\n    </IframeWrapContext.Provider>\n  );\n}\n")),Object(i.b)("p",null,"Similarly, for other types of components, you would build similar wrappers that\ninterface with the component and the host."),Object(i.b)("p",null,"NB: It's important to repeat and clarify: This is to be used ",Object(i.b)("em",{parentName:"p"},"ONLY")," for existing\nlegacy views, and which can't be transitioned to using the primary system (i.e.\nstrategy 1). Do not use it for new views, you'll still face all the problems\nprevalent with a multi-repository system."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Strategy 3"),": Perhaps there's a view (let's call it ",Object(i.b)("inlineCode",{parentName:"p"},"X"),") that exists in a\nseparate repository, but the team's owners/developers are willing to ",Object(i.b)("em",{parentName:"p"},"gradually"),"\ntransition to adopting strategy 1. (if they can transition quickly, then they\nshould simply copy their source over immediately and call it a day.) The\nassumption here, is that this package/view repository is setup up to export a\nReact component, possibly using its own build system and development setup. We\npresent the sequence of steps to take to gradually transition to strategy 1:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Publish ",Object(i.b)("inlineCode",{parentName:"p"},"X")," to a package registry (like an internal npm instance).")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"In the repo generated by ",Object(i.b)("inlineCode",{parentName:"p"},"modular"),", add a workspace with ",Object(i.b)("inlineCode",{parentName:"p"},"modular add <name>"),",\nwhere ",Object(i.b)("inlineCode",{parentName:"p"},"<name>")," is similar to the target view ",Object(i.b)("inlineCode",{parentName:"p"},"X")," (let's say ",Object(i.b)("inlineCode",{parentName:"p"},"X-wrap"),"). In this\nview's main file (probably index.js), import ",Object(i.b)("inlineCode",{parentName:"p"},"X"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Setup a system, either manual or automated, where updates to X are picked up,\nand updated in ",Object(i.b)("inlineCode",{parentName:"p"},"X-wrap"),"'s package.json. Some options for doing this"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"the team that updates X can send a PR to the main repo that updates the\npackage version")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"On a periodic basis, the host repository could run something like\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.npmjs.com/package/npm-check-updates"}),"ncu")," on every ",Object(i.b)("inlineCode",{parentName:"p"},"*-wrap"),"\nworkspace, updating to the latest version.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"A bot could listen to the registry for version updates and automatically\nsend a PR that updates the version number (and possibly commits it)")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Local development in this system is also relatively straightforward;\ndevelopers will checkout the host repository on their local machines (either\ncompletely, or as a sparse checkout), and use\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.npmjs.com/cli/link"}),"npm link")," to point to their view repository.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Once the development-publish cycle is setup, then developers can take steps to\nremove any bespoke build/development assumptions, moving to the relatively\nvanilla assumptions that ",Object(i.b)("inlineCode",{parentName:"p"},"modular")," expects.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Once that is done, and assuming that this team would like to participate in\nall the benefits of a colocated repository system, the entire view's source\ncode can be moved into a new workspace ",Object(i.b)("inlineCode",{parentName:"p"},"X")," in the host's repository, and the\nview can stop publishing to the registry.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Optionally (but recommended), ",Object(i.b)("inlineCode",{parentName:"p"},"X-wrap")," can be removed as a top level\nworkspace, and layouts in the layout registry can rename all instances of\n",Object(i.b)("inlineCode",{parentName:"p"},"X-wrap")," with ",Object(i.b)("inlineCode",{parentName:"p"},"X"),"."))),Object(i.b)("p",null,"This strategy achieves most of the niceties of strategy 1, but provides deeper\ndecoupling abilities, at the cost of overhead of versioning and more complexity\nin managing upgrades of modules/interfaces. It should ideally be done as quickly\nas possible, moving to strategy 1 as soon as possible, or else one can expect\ntime and effort to be spent managing upgrades to the system (from both upgrades\nto third party dependencies, or general changes to the type signatures of the\nsystem)."))}c.isMDXComponent=!0}}]);